; July 21/12: This now requires the predicates in "logical-form-predicates.lisp"
; -- ones like like quan?, verbal-pred?, tense-op? (originally quantifier, 
; verbal-predicate, tense-op)
;
;    And what about adverbial deindexing? Use a simple TTT-based method
;    for now?? They're not too complicated, essentially producing a
;    conjunction of a predication about the "focal" event (which
;    generally ends up as the "** e" event for the wff being modified).
;    adv-e adverbials were treated by us in '94 as semantically sentence
;    modifying, and this seems right in view of cases like
;      "No-one spoke for an hour",
;    where we can have a wide-scope "for an hour" reading (where no-one
;    spoke).
; ========================================================================
;                                                      Initiated Dec 7/03
;
; PROGRAMS FOR DEIDEXING TENSE AND TIME ADVERBIALS, INTRODUCING EXPLICIT
; EPISODIC (EVENT & SITUATION) VARIABLES AND EXPLICIT RELATIONS BETWEEN
; THEM. (*** Actually, the time adverbials aren't done yet; the rules stated
; for adv-e, adv-f and clausal adverbials in the 1994 "Interpreting tense ..."
; paper wouldn't be too hard to incorporate into the deindex program; 
; the MULT and SUB sentential operators, creating repetitive events and
; a third type of embedding (in a scope island), respectively, would 
; have to be handled.)
;
; Nov 5/10: [ ]-extensions have been replaced by dot-extensions.
;
; The main routine is 'deindex'.
;
; For example, suppose we process 2 successive sentences, whose scoped
; logical forms are as indicated:
;
; 1. My mother called.
;    (PAST (THE.DET Y ((Y MOTHER.N) AND.CC (ME.PRON HAVE.V Y)) 
;                      (Y CALL.V)))
; 2. She told me she was sick.
;    (PAST (SHE.PRON TELL.V ME.PRON
;            (THAT.COMPL (PAST (SHE.PRON (BE.V SICK.A))))))
;
; If there is no prior context, the deindexing programs set up a TENSE TREE,
; which will be accessed repeatedly in the dialogue. (If there is a prior
; context, the existing tense tree will be accessed.) Initially the tense tree
; is just a root node, and this node is "in focus". It can be thought of as
; a "hook" at which successive speech acts get attached, represented as a list
; of speech events. Story events get attached to non-root nodes in the tree,
; with new branches being created as-needed.
;
; Without going into detail, the deindexing of each of the LFs (1) and (2)
; has 2 effects: a modified LF is returned, with explicit episodes and
; relations among them; and the global tense tree (after being created if 
; necessary) is updated, with introduction of new branches and/or placement
; of new episode tokens at its nodes. Branches can be pictured as going down
; to the left (past), straight down (perfect), down to the right (future),
; or horizontally to the right (embedding). In particular, the deindexed LF
; for (1) will be
;
; 1'. (exists e1 (e1 same-time Now1)
;        ((Speaker tell Hearer
;            (That (exists e2 (e2 before e1)
;                     ((THE.DET Y ((Y MOTHER.N) AND.CC (ME.PRON HAVE.V Y)) 
;                                  (Y CALL.V)) ** e2) ))) ** e1))
; At the same time, the tense tree will now have the list of speech events
; (e1) at the root node, and it will have a "past branch", directed downward
; and to the left from the root. At the leaf node reached by this past branch,
; there will be the list of (reported) episodes (e2). (Note that e2 is the
; event of the speaker's mother calling.) If now (2) is deindexed, the resulting
; LF will be
;
; 2'. (exists e3 ((e3 same-time Now2) and (e1 immediately-precedes e3))
;       ((Speaker tell Hearer
;          (That (exists e4 ((e4 before e3) and (e2 orients e4))
;                   ((SHE.PRON TELL.V ME.PRON
;                      (THAT.COMPL 
;                        (exists e5 ((e5 before Now2) and (e5 at-about e4))
;                           ((SHE.PRON (BE.V SICK.A)) ** e5)))) ** e4)))) ** e3))
; Again the tense tree will have been modified, so that now two speech events
; (e1 e3) are listed at the root node, two reported events (e2 e4) are at
; the past node (the calling event and the telling-that-mother-is-sick event),
; and there will be an "embedding" branch (generated by the embedded that-clause)
; from the past node to a new node, where the new node has (e5) listed at it
; (the being-sick episode). Note that the deindexed LF contains "before"
; predications expressing that the reported events are sometime before the time
; of speech (this is how past tense is captured), and also (e2 orients e4),
; which expresses that the calling event e2 is the "point of orientation"
; (in G. Leech's terminology) for the telling-that-mother-is-sick event; by
; default, this can be further converted to (e4 right-after e2), i.e.,
; the calling and telling happened in immediate succession. And furthermore,
; the predication (e5 at-about e4) indicates that the being-sick episode
; is around the time of the calling event (mother is sick at the time she 
; calls).
;
; Note that further processing of the deindexed logical forms can easily
; "detach" the reported information from the speech acts. If we assume the
; speaker is truthful (as we normally would), then we can infer from (1')
; that
; 1". (exists e2 (e2 before e1) 
;        ((THE.DET Y ((Y MOTHER.N) AND.CC (SPEAKER HAVE.V Y)) 
;                     (Y CALL.V)) ** e2) )
; and after Skolemization of existential variables, and splitting of explicit
; and implicit conjunctions, we will get
;
; 1 a. (E2 before E1)
;   b. ((THE.DET Y ((Y MOTHER.N) AND.CC (SPEAKER HAVE.V Y)) 
;                   (Y CALL.V)) ** E2)
;
; Note that at this point E1 and E2 are episode constants, rather than variables.
; In a Davidsonian approach the event constant E2 would be "moved into" the
; CALL-predication: (Y CALL.V E2), and the "** E2" would be dropped; similarly
; E1 would be moved into the speech-act TELL-predication: (Speaker TELL.V
; Hearer (That ...) E1). E1 and E2 are then ordinary predicate arguments, like
; any others. (The Davidsonian approach doesn't always work, but should work
; for most of the cases encountered in our project). Of course, another
; remaining processing step is referent determination. In this case a constant
; would be introduced for the speaker's mother (replacing the Y-variable) and
; the restrictions on Y would become separate restrictions on that constant:
; 
; 1 b'.  (MOTHER1.SK-NAME CALL.V E2)
;   b".  (MOTHER1.SK-NAME MOTHER.N)
;   b'". (SPEAKER HAVE.V MOTHER1.SK-NAME)
;
; We would probably also want to use an inference rule to combine 1(b", b'")
; into a single predication, (SPEAKER HAVE-AS-MOTHER.V MOTHER1.SK-NAME).
;-----------------------------------------------------------------------------


(defstruct tt ; tense tree
   root                 ; pointer to root node, from which branches emerge;
                        ; (embedding branches only, at the root node, i.e.,
                        ; roughly, the speech acts embed their content)
   last-augmented-nodes ; the list of nodes that had episode tokens added
                        ; to them in the processing of the last utterance
                        ; (or should it be "last clause"?) -- these are
                        ; intended as possible "story resumption points";
 )

(defstruct node
   ep-stack ; successively added episode tokens, latest topmost
   past-dominated ; true if there's a past-branch in the node's ancestry
   parent past-branch perf-branch futr-branch embedding-branches ) 
  

(defparameter *tt* ; global tense tree structure 
  (make-tt 
     :root (make-node) ))

(defparameter *utt* nil); last-created utterance token (an episode, but
                        ; we use u0, u1, ... for readability)
(defparameter *ep* nil); last-created episode token

(defparameter *now* nil); last-created now-token

(defun new-tt ( )
;~~~~~~~~~~~~~~~
; Reinitialize the global tense tree
;
  (setq *tt* (make-tt :root (make-node)))
  (setq *utt* nil)
  (setq *ep* nil)
  (setq *now* nil) )


(defun new-ep ( )
;~~~~~~~~~~~~~~~~
; Create a new episode token, with a suffix whose index is one more than
; that of the last-created episode token
;
  (cond ((null *ep*) 
         (setf (get 'e0 'index) 0) 
         (setq *ep* 'e0) )
        (t (let* ((i (+ (get *ep* 'index) 1))
                  (ep (intern (format nil "E~a" i))) )
                 (setf (get ep 'index) i)
                 (setq *ep* ep) ))
 )); end of new-ep


(defun new-utt ( )
;~~~~~~~~~~~~~~~~~
; Create a new utterance token, with a suffix whose index is one more than
; that of the last-created utterance token
;
  (cond ((null *utt*) 
         (setf (get 'u0 'index) 0) 
         (setq *utt* 'u0) )
        (t (let* ((i (+ (get *utt* 'index) 1))
                  (utt (intern (format nil "U~a" i))) )
                 (setf (get utt 'index) i)
                 (setq *utt* utt) ))
 )); end of new-utt


(defun new-now ( )
;~~~~~~~~~~~~~~~~~
; Create a new Now-token, with a suffix whose index is one more than
; that of the last-created Now-token; mark the new token with its date 
; and time (a 6-tuple);
;
  (cond ((null *now*)
         (setf (get 'NOW0 'index) 0) 
         (setf (get 'NOW0 'date-and-time) (date-and-time))
         (setq *now* 'NOW0) )
        (t (let* ((i (+ (get *now* 'index) 1))
                  (now (intern (format nil "NOW~a" i))) )
                 (setf (get now 'index) i)
                 (setf (get now 'date-and-time) (date-and-time))
                 (setq *now* now) ))
 )); end of new-now

           
(defun date-and-time ( )
;~~~~~~~~~~~~~~~~~~~~~~~
; Output a 6-tuple giving the current date and time, e.g., (2003 12 9 20 5 4)
;
   (reverse (butlast (multiple-value-list (get-decoded-time)) 3)) )


; Functions defined on nodes of the tense tree:
; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

(defun last-ep (node);
;~~~~~~~~~~~~~~~~~~~~
; This is the episode token stored last at the given node of *tt*
;
  (cond ((null (node-ep-stack node)) nil)
        (T (car (node-ep-stack node))) ))

(defun emb-ep (node);
;~~~~~~~~~~~~~~~~~~~
; This is the episode token last added at the given node, except that when
; the given node is the root of *tt*, the value is (now *tt*) 
  (cond ((eq node (tt-root *tt*)) *now*)
        (t (car (node-ep-stack node))) )); (empty stack --> error)

(defun bef (node)
;~~~~~~~~~~~~~~~~
; This is 'before' if there is no past-branch in the ancestry of 'node',
; and is 'at-or-before' otherwise.
;
  (if (node-past-dominated node)
      'at-or-before
      'before ))
      
(defun add-ep (e node)
;~~~~~~~~~~~~~~~~~~~~~
; This modifies *tt* by pushing e onto the ep-stack of the given node.
; Also, add node to the stack of last-augmented nodes of *tt*. Return 
; the (modified) input node.
;
  (push e (node-ep-stack node)) 
  (push node (tt-last-augmented-nodes *tt*))
  node )

(defun shift-past (node)
;~~~~~~~~~~~~~~~~~~~~~~~
; "Shift focus" to the past node ("down to the left"), if any, creating
; a new node if necessary. Return the (new or old) past-node (as "focus")
;
  (if (null (node-past-branch node))
      ; no past-branch from given node
      (let ((node1 (make-node :parent node :past-dominated t)))
           (setf (node-past-branch node) node1) ))
  (node-past-branch node) ); end of shift-past

(defun shift-perf (node)
;~~~~~~~~~~~~~~~~~~~~~~~
; "Shift focus" to the perf node ("straight down"), if any, creating a new
; node if necessary; return the (new or old) perf (as "focus").
;
  (if (null (node-perf-branch node))
      ; no perf-branch from focal node
      (let ((node1 (make-node :parent node
                     :past-dominated (node-past-dominated node) )))
                     ; inherit past-dominated feature
           (setf (node-perf-branch node) node1) ))
  (node-perf-branch node) ); end of shift-perf

(defun shift-futr (node)
;~~~~~~~~~~~~~~~~~~~~~~~
; "Shift focus" to the futr node ("down to the right"), if any, creating a new
; node if necessary; return the (new or old) futr (as "focus").
;
  (if (null (node-futr-branch node))
      ; no futr-branch from focal node
      (let ((node1 (make-node :parent node
               :past-dominated (node-past-dominated node) )))
           (setf (node-futr-branch node) node1) ))
  (node-futr-branch node) ); end of shift-futr

(defun shift-reembed (node)
;~~~~~~~~~~~~~~~~~~~~~~~~~
; "Shift focus" to the node ("straight to the right") reached by the last-
; added embedding link at 'node', if any, creating a new node if necessary
; Return the (old or new) node accessed as "focus".
;
  (if (null (node-embedding-branches node))
      ; no embedding branches from given node
      (let ((node1 (make-node :parent node
                     :past-dominated (node-past-dominated node) )))
           (setf (node-embedding-branches node) (list node1)) ))
  (car (node-embedding-branches node)) ); end of shift-reembed

(defun shift-embed (node)
;~~~~~~~~~~~~~~~~~~~~~~~
; Create a new embedded node at the given node and shift focus to that node 
; ("straight to the right").
;
  (let ((node1 (make-node :parent node
                 :past-dominated (node-past-dominated node) )))
       (push node1 (node-embedding-branches node))
       node1 
 )); end of shift-embed


;; Note: actual focus shifts in processing an indexical LF just correspond
;; to recursive traversal of *tt*. Return of "focus" to a parent node is
;; an automatic by-product of the return from a recursive call.


(defun deindex (ilf)
;~~~~~~~~~~~~~~~~~~~
; The indexical (but scoped) logical form 'ilf' is assumed to correspond
; to a complete utterance; hence a speech-act predication is added at the
; top level. The deindexing at lower levels is done by 'deindex-at-lower-level'.
; The output is the deindexed LF, and the side effect is to modify the global
; tense tree structure *tt* to reflect the episodes added by the new input.
;
; ilf is assumed to have all keywords in place (note that 'scope-ulf' in
; "scoping.lisp" adds missing keywords, if any, to the ulf that it scopes)
;
  (let (mood u now focus restrictor lf)
       ; Determine whether the mood of the utterance is declarative,
       ; interrogative, direct imperative, or "let's"-imperative, and introduce
       ; a corresponding surface speech act, and recursively deindex relative
       ; to tense tree *tt*;
       ;
       (setq mood (mood ilf))
       (setq u (new-utt))
       (setq now (new-now))
       (setq restrictor `(:i ,u same-time ,now))
       (setq focus (tt-root *tt*))
       (if (last-ep focus); Is there a previous utterance?
           (setq restrictor 
                `(:i ,restrictor and 
                     (:i ,u right-after ,(last-ep focus)) )))
       (setq lf
         (case mood
            (decl `(exists ,u ,restrictor
                     (:i (:i Speaker tell.v Hearer
                           (:f That ,(deindex-at-lower-level ilf focus
                                      (shift-reembed (add-ep u focus)) ))) ** ,u )))
            (ques `(exists ,u ,restrictor
                     (:i (:i Speaker ask.v Hearer
                           (:f QNOM ,(deindex-at-lower-level ilf focus  
                                     (shift-reembed (add-ep u focus)) ))) ** ,u )))
            (imper `(exists ,u ,restrictor
                       (:i (:i Speaker instruct.v Hearer
                             (:f Ka ,(deindex-at-lower-level ilf focus
                                      (shift-reembed (add-ep u focus)) ))) ** ,u )))
            (lets `(exists ,u ,restrictor
                     (:i (:i Speaker propose-to.v Hearer
                          (:f Ka ,(deindex-at-lower-level ilf focus
                                    (shift-reembed (add-ep u focus)) ))) ** ,u )))))
       lf
 )); end of deindex


(defun deindex-at-lower-level (ilf emb-node focus);
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; Deindex a clause or other phrase (ilf) relative to tense tree nodes emb-node
; and focus, where emb-node is the embedding node dominating the focus and
; focus is the start (focal) node for the deindexing of ilf.
;
  (let (op e e-emb new-focus restrictor nucleus lf)
       (cond ((atom ilf) ilf); ** could deal with indexical reference here,
                             ;    for 'me', 'you', 'now', 'here', 'today', etc.
                             ;    or even other anaphora
             (T (setq op (second ilf))
                (when (tense-op? op); past, pres, futr, fpres, ppres, gpres, perf
                  (setq e (new-ep))
                  (setq e-emb (emb-ep emb-node))
                  (setq restrictor 
                    (case op
                      (past `(:i ,e ,(bef focus) ,e-emb))
                      (pres `(:i ,e at-about ,e-emb))
                      (futr `(:i ,e after ,(last-ep focus)))
                      (fpres `(:i ,e after ,e-emb))
                      (ppres `(:i ,e before ,e-emb))
                      (gpres `(:i ,e encompass ,e-emb))
                      (perf `(:i ,e impinges-on ,(last-ep focus))) ))
                  (setq new-focus
                    (case op (past (shift-past focus))
                             (pres focus)
                             (futr (shift-futr focus))
                             (fpres (shift-futr focus))
                             (ppres (shift-past focus))
                             (gpres focus)
                             (perf (shift-perf focus)) ))
                  (if (last-ep new-focus); Is there a previous episode?
                      (setq restrictor
                           `(:i ,restrictor and
                                (:i ,(last-ep new-focus) orients ,e) )))
                  (setq nucleus
                    `(:i ,(deindex-at-lower-level (third ilf) emb-node
                             (add-ep e new-focus) ) ** ,e ))
                  (return-from deindex-at-lower-level
                            `(exists ,e ,restrictor ,nucleus) ))

                ; not a tense construct
                (cond ((eq op 'prog)
                      `(:f prog 
                          ,(deindex-at-lower-level (third ilf) emb-node focus) )) 
                      ((member op '(that that.compl))
                      `(:f ,op ,(deindex-at-lower-level (third ilf)
                                              focus (shift-embed focus) )))
                      (t; in other cases deindex left-to-right
                        (dolist (subx ilf)
                           (if (member subx '(:a :f :i :l :o :p :q :r))
                               (push subx lf)
                               (push (deindex-at-lower-level subx emb-node focus)
                                     lf )))
                        (reverse lf) ))))
 )); end of deindex-at-lower-level


(defun mood (ilf)
;~~~~~~~~~~~~~~~~
; Classify the (top-level) indexical lf 'ilf' as decl, ques, imper, or lets
; (as in "Let's talk", "Let us begin", or "Let me help you")
;
   (cond ((atom ilf) 'decl); unexpected
         ((eq (car ilf) :f)
          (cond ((eq (second ilf) 'YNQ) 'ques)
                ((quan? (second ilf))
                 (mood (cdr ilf)) ); drop the (unexpected) initial :f
                ((member (second ilf) '(past pres futr fpres ppres gpres perf))
                 (mood (third ilf)) )
                ((wffmod? (second ilf))
                 (mood (third ilf)) )
                ((verbal-pred? ilf) 
                 (if (verbal-pred? (second ilf))
                    'imper ; the functor is itself verbal (e.g., intensional V)
                     (mood (third ilf)) )); drop functor (may be imper or lets)
                (t 'decl) )) ; none of the above -- unexpected
         ((eq (car ilf) :i) 'decl)
         ((member (car ilf) '(wh whose.det what.det which.det)) 'ques)
         ((quan? (car ilf))
          (if (fourth ilf); restricted quantification?
              (mood (fourth ilf))
              (mood (third ilf)) ))
         ((verbal-pred? ilf)
          (if (or (eq (second ilf) 'let.v)
                  (and (eq (car ilf) :p) 
                       (listp (second ilf))
                       (eq (second (second ilf)) 'let.v) ))
              'lets
              'imper ))
         (T 'decl) ; decl by default (unexpected)
 )); end of mood
                    

